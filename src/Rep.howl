âŠ System.Collections.Generic;
âŠ InvOp = System.InvalidOperationException;

âŠ“ Active.Howl{
[System.Serializable]
â€’ á´¾ â—‹ Rep{

    á´¸ ã„¹ Undef = "Undefined symbol";

    â€’ ã„¹ a, b, header, alt, label, prefix, body, _class, _description;

    â€’ ã…‡ bridge = âœ—, import = âœ“, noSnippet = âœ—,  ignoreConflicts = âœ—,
        @sel   = âœ“,  nts = âœ—, nospec = âœ—;

    // Operators ----------------------------------------------------

    â€’Ì¥ ã„¹ â¨• * (ã„¹ x, Rep y) â†’ x.Replace(y.a, y.b);

    â€’Ì¥ ã„¹ â¨• / (ã„¹ x, Rep y){
        â¤´(!y.willImport) â® x;
        â® y.bridge ? x.Replace(y.b, y.a)
                        : (x.Tokenize() / y).Join();
    }

    â€’Ì¥ ã„¹[] â¨• / (ã„¹[] tokens, Rep rule) â†’ Rep.Rev(tokens, rule);

    // Prefix with '-' to remove trailing space from snippets
    â€’Ì¥ Rep â¨• - (Rep x){ x.nts = âœ“; â® x; }

    // Indicates whether this is a "soft" symbol. When converted, a
    // soft symbol may concatenate with previous/next elements,
    // creating errors.
    // TODO this implementation is incorrect. We should only be
    // looking at first and last char.
    â€’Ì¥ ã…‡ â¨• ! (Rep x){
        âˆ™  s = x.b;
        â® á†©.IsLetterOrDigit(s[0]) âˆ§ á†©.IsLetterOrDigit(s[sâ™-1]);
    }

    /* Editor safe symbolic presentation */
    â€’Ì¥ ã„¹ â¨• ~ (Rep x) â†’ x.alt ?? x.a;

    // Properties ---------------------------------------------------

    â€’ ã„¹ name â†’ label ?? b.Trim().Ftu();

    â€’ ã„¹ description â†’ _description ?? label ?? null;

    â€’ ã…‡ nit â†’ !b.IsAlphaNumeric();

    ã…‡ willImport â†’ @sel âˆ§ import;

    // Functions ----------------------------------------------------

    â€’Ì¥ ã„¹[] DivBridging(ã„¹[] tokens, Rep rule){
        ã„¹[] lh = rule.b.Tokenize();
        â® tokens.Replace(lh, âŒ¢ ã„¹[]{rule.a});
    }

    â€’ ã…‡ Encloses(Rep â§•) â†’ â¦¿.bâ™ â˜° â§•.bâ™ ? âœ— : â¦¿.b.âˆ‹(â§•.b);

    â€’ ã…‡ ValueMatches(ã„¹ â§•) â†’ b â˜° â§•;

    âºâ€’ ã„¹ ToString() â†’ $"{name} âŒ{~this}âŒ â†’ âŒ{b}âŒ";

    // Static -------------------------------------------------------

    â€’Ì¥ ã„¹[] Rev(ã„¹[] tokens, Rep rule, ã…‡ ignoreConflicts=âœ“){
        â¤´ (!rule.willImport) â® tokens;
        â¤´ (rule.bridge)      â® DivBridging(tokens, rule);
        ã…‡ checkConflicts = !(ignoreConflicts
                             âˆ¨ rule.ignoreConflicts
                             âˆ¨ (Config.Î¹?.ignoreConflicts ?? âœ—));
        âŸ³ (á† i = 0; i < tokensâ™; i++){
            â¤´ (tokens[i] â˜° rule.b) tokens[i] = rule.a;
            â¤³ (checkConflicts âˆ§ (tokens[i] â˜° rule.a))
                (â•¯Â°â–¡Â°)â•¯ âŒ¢ InvOp($"{rule.a} in input");
        }
        â® tokens;
    }

    â€’Ì¥ Rep[] Reorder(Rep[] x){
        âˆ™ ã„¸ = âŒ¢ ğ•ƒ<Rep>();
        âˆ€(âˆ™ Ï âˆˆ x){
            ã…‡ added = âœ—;
            âŸ³(á† i = 0; i < ã„¸â; i++){
                â¤´(Ï.Encloses(ã„¸[i])){
                    ã„¸.Insert(i, Ï);
                    added = âœ“;
                    Â¦
                }
            }
            â¤´(!added) ã„¸.Add(Ï);
        }
        â® ã„¸à§´;
    }

}}
