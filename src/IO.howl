âŠ System; âŠ System.IO; âŠ System.Linq;
âŠ ArgEx = System.ArgumentException;
âŠ Dir = System.IO.Directory;
âŠ SysPath = System.IO.Path;
âŠ System.Runtime.Serialization.Formatters.Binary;

âŠ“ Active.Howl{
â€’Ì¥ â—‹ IO{

    â€’Ì¥ â”ˆ Clean(â¦¿ ã„¹ dir) {
        âˆ€ (âˆ™ child âˆˆ dir.Dirs()){
            child.Clean();
            child.MetaFile()?.Delete(withMetaFile: âœ—);
            â†¯ { Directory.Delete(child); } â‡¤ (IOException) {}
        }
    }

    â€’Ì¥ â”ˆ CopyFiles(â¦¿ ã„¹ ã…‚, ã„¹ ã„¸, ã„¹ relTo, ã…‡ mkdir, ã…‡ dry,
                                                  â‹¯ ã„¹[] patterns){
        âˆ€ (âˆ™ Ï€ âˆˆ patterns){
            âˆ™ Ïƒ = FileSystem.Paths(ã…‚, Ï€);
            âˆ€ (âˆ™ Ï† âˆˆ Ïƒ) Ï†.CopyTo($"{ã„¸}/{Ï†.RelativeTo(relTo)}",
                                 mkdir: mkdir, dry: dry);
        }
    }

    â€’Ì¥ â”ˆ CopyTo(â¦¿ ã„¹ ã…‚, ã„¹ ã„¸, ã…‡ mkdir, ã…‡ dry=âœ—){
        â¤´ (dry) ğŸ° $"Copy {ã…‚.RelativeTo("Assets")} -> {ã„¸}";
        â¤µ {
            â¤´ (mkdir) ã„¸.DirName().MkDir();
            File.Copy(ã…‚, ã„¸);
        }
    }

    â€’Ì¥  DateTime  DateModified(â¦¿ ã„¹ Ï€) â†’ File.GetLastWriteTime(Ï€);

    â€’Ì¥ â”ˆ DeleteFileOrDir(â¦¿ ã„¹ Ï€, ã…‡ withMetaFile){
        â¤´ (Ï€.IsFile()) Ï€.Delete(withMetaFile);
        â¤´ (Ï€.IsDir()) Ï€.RmDir(withMetaFile);
    }

    â€’Ì¥ â”ˆ JustDelete(â¦¿ ã„¹ Ï€, ã…‡ dry){
        â¤´ (dry) â® ;
        File.Delete(Ï€);
    }

    â€’Ì¥ â”ˆ Delete(â¦¿ ã„¹ Ï€, ã…‡ withMetaFile){
        File.Delete(Ï€);
        â¤´ (withMetaFile) Ï€.MetaFile()?.Delete(withMetaFile: âœ—);
    }

    â€’Ì¥ â”ˆ DeleteFiles(â¦¿ ã„¹ Ï€, ã„¹ pattern, ã…‡ withMetaFile){
        âˆ€ (âˆ™ x âˆˆ FileSystem.Paths(Ï€, pattern)) x.Delete(withMetaFile);
    }

    â€’Ì¥ ã…‡ Exists(â¦¿ ã„¹ Ï€) â†’ File.Exists(Ï€) âˆ¨ Directory.Exists(Ï€);

    â€’Ì¥ ã„¹ FileName(â¦¿ ã„¹ Ï€) â†’ SysPath.GetFileName(Ï€.FullPath());

    â€’Ì¥ ã„¹[] Files(â¦¿ ã„¹ Ï€) â†’ Directory.GetFiles(Ï€);

    â€’Ì¥ ã„¹[] Dirs(â¦¿ ã„¹ Ï€) â†’ Directory.GetDirectories(Ï€);

    â€’Ì¥ ã„¹ DirName(â¦¿ ã„¹ Ï€) â†’ SysPath.GetDirectoryName(Ï€).Nix();

    â€’Ì¥ ã„¹ FullPath(â¦¿ ã„¹ Ï€) â†’ SysPath.GetFullPath(Ï€).Nix();

    â€’Ì¥ ã…‡ IsDir(â¦¿ ã„¹ Ï€) â†’ Directory.Exists(Ï€);

    â€’Ì¥ ã…‡ IsFile(â¦¿ ã„¹ Ï€) â†’ File.Exists(Ï€);

    â€’Ì¥ DirectoryInfo MkDir (â¦¿ ã„¹ Ï€) â†’ Dir.CreateDirectory(Ï€);

    â€’Ì¥ DirectoryInfo MkDir (â¦¿ ã„¹ Ï€, ã…‡ dry)
    â†’ dry ? âˆ… : Dir.CreateDirectory(Ï€);

    â€’Ì¥ ã„¹ MetaFile(â¦¿ ã„¹ Ï€)
    â†’ (Ï€ = Ï€.NoFinalSep() + ".meta").Exists() ? Ï€ : âˆ…;

    â€’Ì¥ â”ˆ MoveFiles(â¦¿ ã„¹ ã…‚, ã„¹ ã„¸, ã„¹ relTo, ã…‡ dry, params ã„¹[] patterns){
        âˆ€ (âˆ™ Ï€ âˆˆ patterns){
            âˆ™ Ïƒ = FileSystem.Paths(ã…‚, Ï€);
            âˆ€ (âˆ™ Ï† âˆˆ Ïƒ) â¤´ (!dry)
                    Ï†.MoveTo($"{ã„¸}/{Ï†.RelativeTo(relTo)}",
                             withMetaFile: âœ“);
        }
    }

    â€’Ì¥ â”ˆ JustMoveTo(â¦¿ ã„¹ ã…‚, ã„¹ ã„¸, ã…‡ dry){
        â¤´ (dry) â® ;
        //ã„¸.DirName().MkDir();
        Directory.Move(ã…‚, ã„¸);
    }

    â€’Ì¥ â”ˆ MoveTo(â¦¿ ã„¹ ã…‚, ã„¹ ã„¸, ã…‡ withMetaFile){
        ã„¸.DirName().MkDir();
        File.Move(ã…‚, ã„¸);
        ã„¹ m0 = ã…‚.MetaFile();
        ã„¹ m1 = ã„¸.PathToMetaFile();
        â¤´ (m0.Exists()) File.Move(m0, m1);
    }

    â€’Ì¥ ã„¹ Nix(â¦¿ ã„¹ x) â†’ x.Replace('\\', '/');

    â€’Ì¥ ã„¹ NoFinalSep(â¦¿ ã„¹ Ï€)
    â†’ (Ï€ = Ï€.Nix()).EndsWith("/") ? Ï€.Substring (0, Ï€â™ - 1) : Ï€;

    â€’Ì¥ ã„¹ PathToMetaFile(â¦¿ ã„¹ Ï€) â†’ Ï€ = Ï€.NoFinalSep() + ".meta";

    â€’Ì¥ ã„¹ Read(â¦¿ ã„¹ Ï€) â†’ File.ReadAllText(Ï€);

    â€’Ì¥ ã„¹ RelativeTo(â¦¿ ã„¹ Ï€, ã„¹ Îº){
        Ï€ = Ï€.FullPath(); Îº = Îº.FullPath();
        â¤´ (Îº[Îºâ™-1] â‰  '/') Îº += '/';
        â® Ï€.StartsWith(Îº) ? Ï€.Substring(Îºâ™)
                   : (â•¯Â°â–¡Â°)â•¯ âŒ¢ ArgEx($"{Ï€} is not a subpath of {Îº}");
    }

    â€’Ì¥ â”ˆ RmDir(â¦¿ ã„¹ Ï€, ã…‡ dry){
        if(!Ï€.IsDir()) â® ;
        âˆ€ (âˆ™ Îº âˆˆ Ï€.Files ()) Îº.JustDelete(dry);
        âˆ€ (âˆ™ Îº âˆˆ Ï€.Dirs  ()) Îº.RmDir(dry);
        Directory.Delete(Ï€);
    }

    â€’Ì¥ â”ˆ RmDir(â¦¿ ã„¹ Ï€, ã…‡ withMetaFile, ã…‡ dry){
        if(!Ï€.IsDir()) â® ;
        âˆ€ (âˆ™ Îº âˆˆ Ï€.Files ())
            Îº.Delete(withMetaFile: withMetaFile);
        âˆ€ (âˆ™ Îº âˆˆ Ï€.Dirs  ())
            Îº.RmDir(withMetaFile);
        â¤´ (withMetaFile)
            Ï€.MetaFile()?.Delete(withMetaFile: âœ—);
        Directory.Delete(Ï€);
    }

    â€’Ì¥ ã„¹[] ReadLines(â¦¿ ã„¹ Ï€) â†’ File.ReadLines(Ï€)à§´;

    â€’Ì¥  T ReadObject<T>(â¦¿ ã„¹ Ï€){
        âˆ™ Ï† = âŒ¢ BinaryFormatter();
        âˆ™ s    = âŒ¢ FileStream(Ï€,  FileMode.Open, FileAccess.Read);
        âˆ™ @out = Ï†.Deserialize(s);
        s.Close();
        â® (T)@out;
    }

    â€’Ì¥  T ReadObject<T>(â¦¿ ã„¹ Ï€, T @default)
    â†’ Ï€.Exists() ? Ï€.ReadObject<T>() : @default;

    â€’Ì¥ long Size(â¦¿ ã„¹ Ï€) â†’ Ï€.Read()â™; //â†’ âŒ¢ FileInfo(Ï€)â™;

    â€’Ì¥ long DrySize(â¦¿ ã„¹ Ï€) â†’ Ï€.Read().Replace(" ", "")â™;

    â€’Ì¥ á† StatementCount(â¦¿ ã„¹ Ï€)
    { ã„¹ x = Ï€.Read(), y = x.Replace(";", ""); â® xâ™ - yâ™; }

    â€’Ì¥ á† NumberOfLines(â¦¿ ã„¹ Ï€) â†’ Ï€.ReadLines()â™;

    â€’Ì¥ ã„¹ WithFinalSep(â¦¿ ã„¹ Ï€)
    â†’ (Ï€ = Ï€.Nix()).EndsWith("/") ? Ï€ : Ï€ + "/";

    â€’Ì¥ â”ˆ Write(â¦¿ ã„¹ Ï€, ã„¹ text, ã…‡ mkdir=âœ—, ã…‡ importAsset=âœ—){
        â¤´ (mkdir) Directory.GetParent(Ï€).Create();
        File.WriteAllText(Ï€, text);
        #if UNITY_EDITOR
        â¤´ (importAsset) UnityEditor.AssetDatabase.ImportAsset(Ï€);
        #endif
    }

    â€’Ì¥ â”ˆ Write(â¦¿ ã„¹ Ï€, ã„¹ text, System.DateTime date){
        Directory.GetParent(Ï€).Create();
        File.WriteAllText(Ï€, text);
        File.SetLastWriteTime(Ï€, date);
    }

    â€’Ì¥  â”ˆ WriteObject(â¦¿ ã„¹ Ï€, object @out){
        âˆ™ Ï† = âŒ¢ BinaryFormatter();
        âˆ™ s = âŒ¢ FileStream(Ï€, FileMode.Create, FileAccess.Write);
        Ï†.Serialize(s, @out);
        s.Close();
    }

    #if UNITY_EDITOR
    âˆ˜ â”ˆ Print(ã„¹ x) â†’ ğŸ¥(x);
    #else
    âˆ˜ â”ˆ Print(ã„¹ x) â†’ Console.WriteLine(x);
    #endif

}}
