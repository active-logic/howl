⊐ Ex = System.Exception;

⊓ Active.Howl{
‒ ○ Builder{

    DotNet δ = ⌢ DotNet();

    ‒ ᆞ Build(ㄹ π){
        Update(π);
        ⮐ δ.Build("-v quiet --nologo", $"{π}/build", dry: ✗);
    }

    ‒ ᆞ Install(ㄹ π){
        ∙ rt = OS.runtime;
        ⤴ (rt ≠ "osx-x64"){
            🐰 $"N/A: 'install' ({rt})";
            ⮐ 1;
        }
        Publish(π, config: "Release", rt);
        ∙ path =
           $"{π}/build/src/bin/Release/netcoreapp3.1/osx-x64/publish";
        ∙ link =
           $"/usr/local/bin/{ProjectName(π)}";
        ⤴ (!path.Exists()) (╯°□°)╯
                                 ⌢ Ex("Binaries path is invalid");
        ⮐ Runner.Cmd(
            "ln", $"-sf {path.FullPath()}/src {link}",
            π, dry: ✗);
    }

    ‒ ᆞ Publish(ㄹ π, ㄹ config = "Debug", ㄹ rt = ∅){
        Update(π);
        ⮐ δ.Publish($"src -c {config} --nologo", $"{π}/build",
                     rt, dry: ✗);
    }

    ‒ ᆞ Run(ㄹ π){
        Update(π);
        ⮐ δ.Run("--project src", $"{π}/build", dry: ✗);
    }

    ‒ ᆞ Test(ㄹ π){
        Update(π);  ⮐ δ.Test($"{π}/build", dry: ✗);
    }

    // ---------------------------------------------------------------

    ‒ ㄹ ProjectName(ㄹ π){
        ∙ Π = π.FullPath();
        ⮐ Π.Substring(Π.LastIndexOf("/") + 1).ToLower();
    }

    ‒ ᆞ Update(ㄹ π){
        ∙ β = $"{π}/build";
        ⤴ ( β.∃() ) β.DeleteFiles("*.cs", withMetaFile: ✗);
        Export(∅, $"{π}/src", $"{β}/src");
        Export(∅, $"{π}/test", $"{β}/test");
        ⮐ Solution(β, dry: ✗);
    }

    // TRANSITIONAL
    ‒ ㄹ Export(⋯ ㄹ[] ㅂ){
        ㅇ dry = ✗;
        ㄹ src = ㅂ[1].WithFinalSep(),
          dst = ㅂ[2].WithFinalSep();
        ⤴ (!src.IsDir()) ⮐ $"Source dir not found: {src}\n";
        ∙ paths = FileSystem.Paths(src, "*.howl");
        ⤴ (dry){
            ⮐ ∅;
        }
        ∀ (∙ x ∈ paths){
            ∙ y = dst + x.RelativeTo(src).SetExtension(".cs");
            🐰y;
            Howl.BuildFile(x, y);
        }
        ⮐ "Exported some files";
    }

    ‒ ᆞ Solution(ㄹ π, ㅇ dry){
        ᆞ ㄸ = 0;
        ⤴ (!$"{π}/Main.sln".∃()){
            π.MkDir();
            ㄸ = δ.New($"solution --force -n Main", π, ∅, dry);
            $"{π}/src/src.csproj".Write(newConsole, mkdir: true);
            $"{π}/test/test.csproj".Write(newNUnit, mkdir: true);
            ㄸ = δ["sln add",
               "src/src.csproj test/test.csproj", π, dry];
        } ⮐ ㄸ;
    }

    ‒ ᆞ SlowSolution(ㄹ π, ㅇ dry){
        ᆞ ㄸ = 0;
        ⤴ (!$"{π}/Main.sln".∃()){
            π.MkDir();
            ∙ opts = "--force --no-restore";
            // NOTE: dotnet [new solution | sln | add ] do not accept
            // --no-restore
            ㄸ = δ.New($"solution --force -n Main", π, ∅, dry);
            ㄸ = δ.New($"console {opts} -n src", π, ∅, dry);
            ㄸ = δ.New($"nunit {opts} -n test", π, ∅, dry);
            $"{π}/src/Program.cs".JustDelete(dry);
            // This is for libraries
            // $"{π}/src/Class1.cs".JustDelete(dry);
            $"{π}/test/UnitTest1.cs".JustDelete(dry);
            ㄸ = δ["add",
                "test/test.csproj reference src/src.csproj", π, dry];
            ㄸ = δ["sln add",
               "src/src.csproj test/test.csproj", π, dry];
        } ⮐ ㄸ;
    }

    ᴸ ㄹ newConsole =
@"<Project Sdk=""Microsoft.NET.Sdk"">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>netcoreapp3.1</TargetFramework>
  </PropertyGroup>
</Project>";

    ᴸ ㄹ newNUnit =
@"<Project Sdk=""Microsoft.NET.Sdk"">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.1</TargetFramework>
    <IsPackable>false</IsPackable>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include=""nunit"" Version=""3.12.0"" />
    <PackageReference Include=""NUnit3TestAdapter"" Version=""3.15.1"" />
    <PackageReference Include=""Microsoft.NET.Test.Sdk"" Version=""16.4.0"" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include=""..\src\src.csproj"" />
  </ItemGroup>
</Project>";

}}
