âŠ InvOp = System.InvalidOperationException;
âŠ System.Collections ;
âŠ System; âŠ System.Collections.Generic; âŠ System.Linq;
âŠ System.Text;

âŠ“ Active.Howl {
â€’ á´¾ â—‹ Map : IEnumerable{

    â€’ Rep[] declarative, rules;

    // Factory ------------------------------------------------------

    â’¤ Map(Rep[] â§•)
    â†’ âŒ¢ Map(){ declarative = â§•, rules = Rep.Reorder(â§•) };

    // Operators ----------------------------------------------------

    â€’Ì¥ ã„¹   â¨• * (ã„¹ x, Map y) â†’ Forw(y.Consolidate(x), y.rules);

    â€’Ì¥ ã„¹   â¨• / (ã„¹ x, Map y) â†’ Rev(x, y.rules);

    â€’Ì¥ ã„¹[] â¨• / (ã„¹[] A, Map y) â†’ (â€– x âˆˆ A â–¸ x / y)à§´;

    â€’Ì¥ ã„¹   â¨• % (ã„¹ x, Map y) â†’ Rev(x, y.nits, ignoreConflicts: âœ“);

    â€’Ì¥ ã„¹[] â¨• ! (Map m) â†’ (â€– x âˆˆ m.rules Â¿ !x â–¸ x.a)à§´;

    // Functions ----------------------------------------------------

    â€’ â”ˆ Rebuild(Rep[] â§•) { declarative = â§•; rules = Rep.Reorder(â§•); }

    // Get information ----------------------------------------------

    â€’ á† count â†’ rulesâ™;

    â€’ ã…‡ integer{ â•­{
        âˆ™ @set = âŒ¢ ğ•„ <ã„¹, ğ•ƒ<Rep>>();
        âˆ€(âˆ™ x âˆˆ rules){
            ğ•ƒ <Rep> Î³ = @set.â‹º(x.a)
                      ? @set[x.a] : @set[x.a] = âŒ¢ ğ•ƒ<Rep>();
            Î³.Add(x);
        }
        ã…‡ hasConflicts = âœ—;
        âˆ€(âˆ™ z âˆˆ @setá–¾s){
            â¤´(zâ > 1){
                // TODO who should see this?
                ğŸ”¸($"[{z[0].a}] has conflicts ({z.Count})");
                hasConflicts = âœ“;
            }
        }
        â® !hasConflicts;
    }}

    // TODO: return IEnumerable instead
    â€’ Rep[] nits
    â†’ (â€– Ï âˆˆ rules Â¿ Ï.nit â–¸ Ï)à§´;

    â€’ Rep[] ForClass(ã„¹ @class)
    â†’ (â€– Ï âˆˆ rules Â¿ Ï._class â˜° @class â–¸ Ï)à§´;


    â€’ á† â¦¿[ã„¹ key]{â•­{
        âŸ³(á† i = 0; i < rulesâ™; i++){
            â¤´(rules[i].ValueMatches(key)) â® i;
        }
        (â•¯Â°â–¡Â°)â•¯ âŒ¢ InvOp("Bad Key");
    }}

    â€’ Rep Rule(ã„¹ key){
        âŸ³(á† i = 0; i < rulesâ™; i++){
            â¤´(rules[i].ValueMatches(key)) â® rules[i];
        }
        (â•¯Â°â–¡Â°)â•¯ âŒ¢ InvOp("Bad Key");
    }

    â€’ IEnumerator GetEnumerator() â†’ declarative.GetEnumerator();

    // IMPLEMENTATION -----------------------------------------------

    â€’Ì¥ ã„¹ Forw(ã„¹ x, Rep[] Ï){
        âˆ™ ã„¸ = âŒ¢ StringBuilder();
        âˆ€(âˆ™ Î¸ âˆˆ x.Break(defs))
            ã„¸.Â±(Î¸.DenotesBlock(defs) ? Î¸ : ForwChunk(Î¸, Ï));
        â® ã„¸ğŸ ;
    }

    â€’Ì¥ ã„¹ Rev(ã„¹ x, Rep[] Ï, ã…‡ ignoreConflicts=âœ“){
        âˆ™ ã„¸ = âŒ¢ StringBuilder();
        âˆ€(âˆ™ Î¸ âˆˆ x.Break(defs))
            ã„¸.Â±(Î¸.DenotesBlock(defs) ? Î¸
            : RevChunk(Î¸, Ï, ignoreConflicts));
        â® ã„¸ğŸ ;
    }

    âˆ˜ ã„¹ ForwChunk(ã„¹ x, Rep[] Ï){
        âˆ€(âˆ™ r âˆˆ Ï) x *= r;
        â® x;
    }

    âˆ˜ ã„¹ RevChunk(ã„¹ x, Rep[] Ï, ã…‡ ignoreConflicts){
        ã„¹[] tokens = x.Tokenize();
        ğ•ƒ<ã„¹> conflicts = âˆ…;
        âˆ€(âˆ™ r âˆˆ Ï){
            â†¯{
                tokens = Rep.Rev(tokens, r, ignoreConflicts);
                // TODO - not ready for this
                tokens =  Modifiers.NitpickSegment(tokens);
            }â‡¤(InvOp ex){
                â¤´(conflicts â˜° âˆ…) conflicts = âŒ¢ ğ•ƒ<ã„¹>();
                conflicts.Add(ex.Message);
            }
        }
        â¤´(conflicts â‰  âˆ…) (â•¯Â°â–¡Â°)â•¯
            âŒ¢ InvOp("\n" + conflictsà§´.Join('\n'));
        â® tokens.Join();
    }

    â€’ ã„¹ Consolidate(ã„¹ x){
        âˆ™ ã„¸ = âŒ¢ StringBuilder();
        âˆ€(âˆ™ Î¸ âˆˆ x.Break(defs))
            ã„¸.Â±(Î¸.DenotesBlock(defs) ? Î¸ : Î¸.Consolidate(!â¦¿));
        â® ã„¸ğŸ ;
    }

    âˆ˜ â”ˆ Print(ã„¹ x) â†’ ğŸ¥(x);

    // ==============================================================

    â€’Ì¥ Block.Def[] defs = âŒ¢ Block.Def[]{
        ("\"","\""),  // string literal
        ("/*","*/"),  // C style comment
        "//",         // C++ style comment
        "#",          // Directive
    };

    â€’Ì¥ Rep Î¼(ã„¹ ã…‚, ã„¹ ã„¸, ã„¹ name=âˆ…, ã„¹ px=âˆ…, ã„¹ alt=âˆ…, ã…‡? bridge=âˆ…,ã…‡ Î¹=âœ—,
         ã„¹ H=âˆ…, ã…‡ Ï€=âœ“, ã…‡ ns=âœ—, ã…‡ q=âœ—, ã„¹ d=âˆ…)
    â†’ âŒ¢ Rep(ã…‚, ã„¸, name, px, alt, bridge, Î¹, H, Ï€, ns, q, d);

}}
